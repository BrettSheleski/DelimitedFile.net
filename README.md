# Sheleski.DelimitedFile
Library for parsing and saving CSV and Tab Delimited Files in .NET.

## Usage

The `CsvFile` has a very simple API with `Headers` and `Values` properties.  Use these properties to work with the data in the CSV file.

```C#
CsvFile csv = new CsvFile();

csv.Headers = new string[]{ "First Name", "Last Name" };
csv.Values = new string[][]
{
  new string[]{"Joe", "Blow"},
  new string[]{"Bonehead", "McGee"}
};
```

### Save the CSV to file

```C#
csv.Save("c:\\temp\\names.csv");
```

### Write the CSV to any arbitrary `TextReader`

```C#
using (var writer = new StringWriter())
{
    csv.Write(writer);

    string csvString = writer.ToString();
}
```

### Load a CSV from a  stream
```C#
WebRequest request = HttpWebRequest.Create("https://raw.githubusercontent.com/forxer/languages-list/master/src/Languages.csv");
using (WebResponse response = await request.GetResponseAsync())
using (var stream = response.GetResponseStream())
using (var reader = new StreamReader(stream))
{
  var csvFile = CsvFile.Load(reader, CsvFileLoadOptions.WithHeaders);
}
```

# Create a Delimited File from any IEnumerable easily.

You can easily generate a CSV file from a collection.

Start with a Person class.

```C#
class Person
{
    [Display(Order = 1, Name = "First Name")]
    public string FirstName { get; set; }

    [Display(Order = 2, Name = "Last Name")]
    public string LastName { get; set; }

    [Display(Order = 3, Name = "Birth Date")]
    public DateTime BirthDate { get; set; }

    [Display(Order = 4, Name = "Death Date")]
    public DateTime? DeathDate { get; set; }

    [Display(Order = -1)]
    public string InvisibleInfo { get; set; }

    [Display(Order = 4)]
    public List<Person> Children { get; } = new List<Person>();
}
```

Now lets create some people and make a CSV File from it.

First make sure to include the using directive.

```C#
using Sheleski.DelimitedFile;
```

Now we can make use of the `.ToCsvFile()` extension method.

```C#
Person[] people = new Person[]
{
    new Person{FirstName = "Elvis", LastName = "Presley", BirthDate = new DateTime(1935, 1, 8), DeathDate= null, InvisibleInfo = "Dead??"},
    new Person{FirstName = "Abraham", LastName = "Lincoln", BirthDate = new DateTime(1809, 2, 12), DeathDate = new DateTime(1865, 4, 15), InvisibleInfo = "Dead"},
};

CsvFile csvFile = people.ToCsvFile();

```

Resulting CSV string:
```csv
First Name,Last Name,Birth Date,Death Date,Children
Elvis,Presley,1/8/1935 12:00:00 AM,,System.Collections.Generic.List`1[Sheleski.DelimitedFile.Tests.CsvFile_EnumerableExtensions+Person]
Abraham,Lincoln,2/12/1809 12:00:00 AM,4/15/1865 12:00:00 AM,System.Collections.Generic.List`1[Sheleski.DelimitedFile.Tests.CsvFile_EnumerableExtensions+Person]
```

## Automatic Column Mapping

If you do not pass a mapping to the `.ToCSVFile()` extension method, then it will generate an automatic mapping by looking at the DisplayAttributes assigned to the properties.

The `Order` property of the `DisplayAttribute` determines the order of the columns generated in the resulting Delimited File.

*Note:  If you do not want a column to be added to the resulting delimited file, the `Order` property can be set to a negative value.*

The `Name` property of the `DisplayAttribute` determines the column header generated for the associated property.

The values used to populate the delimted file are generated by simply calling the `ToString()` method of each property.

## Custom Column Mapping

```C#
DelimitedFileObjectMapping<Person> mapping = new DelimitedFileObjectMapping<Person>();
mapping.AddProperty(x => x.BirthDate).WithValue(d => d.ToShortDateString()).WithHeader("B-Day");
mapping.AddProperty(x => x.LastName);
mapping.AddProperty(x => x.FirstName).WithHeader("F Name");
mapping.AddProperty(x => x.DeathDate);

mapping.Add("Row Index", (x, i) => i.ToString());


CsvFile csvFile = people.ToCsvFile(mapping);
```

The example above shows how to add mappings to generate a CSV file by adding the Properties.  You can also add computed values as well (See the Row Index example above).